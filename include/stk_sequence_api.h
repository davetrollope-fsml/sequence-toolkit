/** @file stk_sequence_api.h
 * This file contains the implementation of the Sequence object. The Sequence object
 * is the center of the Sequence Toolkit API. Sequence objects are passed between every module
 * in the system and the APIs in this module make it possible. Sequencing objects are
 * used to pass data between services. All data communication between services are
 * implemented by passing Sequence object with the data and meta data in them.
 */
#ifndef STK_SEQUENCE_API_H
#define STK_SEQUENCE_API_H

#include "stk_sequence.h"
#include "stk_service.h"
#include "stk_env.h"

/**
 * Create a sequence object.
 *
 * Only the stk_env is mandatory.
 *
 * The name is copied and may be freed by the application.
 *
 * Use NULL or STK_SEQUENCE_ID_INVALID to get default values for name and id.
 * Default Sequence ID's are allocated/released calling stk_acquire_sequence_id() and stk_release_sequence_id().
 * There are no invalid values for type or svctype. Rapid reuse of the same ID is not supported - always create
 *
 * \returns An allocated object. Free with stk_destroy_sequence()
 * \see stk_acquire_sequence_id()
 */
stk_sequence_t *stk_create_sequence(stk_env_t *env, char *name, stk_sequence_id id, stk_sequence_type type, stk_service_type svctype, stk_options_t *options);

/**
 * Destroy an allocated sequence object.
 * \returns Whether the Sequence was successfully destroyed
 */
stk_ret stk_destroy_sequence(stk_sequence_t *seq);

/**
 * Hold a sequence - this increments a reference count.
 * Use stk_destroy_sequence() to relinquish the hold.
 * \see stk_destroy_sequence
 */
void stk_hold_sequence(stk_sequence_t *seq);

/**
 * Acquire a sequence ID from the STK environment.
 *
 * Sequence ID's are currently generated by using rand(), but in the future
 * will be managed per type of service.
 * A sequence ID is atomic so the stkenv must be passed in to both acquire and release an ID
 * \see stk_release_sequence_id()
 */
stk_sequence_id stk_acquire_sequence_id(stk_env_t *env,stk_service_type type);

/**
 * Release a sequence ID from the STK environment.
 * A sequence ID is atomic so the stkenv must be passed in to both acquire and release an ID
 */
stk_ret stk_release_sequence_id(stk_env_t *env,stk_sequence_id);

/**
 * Add some referenced data to the sequence.
 *
 * The sequence, data pointer and size must all be non-null or non-0.
 *
 * The data is NOT copied - it is the application responsibility to ensure the integrity of data 
 * is maintained between this function being called and when other functions use this sequence.
 * I.E. The API's don't provide thread safety for the data
 *
 * This API is specifically designed to allow you to reuse a sequence while data is changed,
 * but it is recommended you call stk_update_ref_data_in_sequence() *before* updating data
 * to ensure data archiving can occur as needed.
 *
 * \returns Whether the reference was successfully added to the Sequence
 */
stk_ret stk_add_reference_to_sequence(stk_sequence_t *seq,void *data_ptr,stk_uint64 sz, stk_uint64 user_type);

/**
 * Add a sequence (merge_seq) to another sequence as a reference
 *
 * Using stk_iterate_sequence() will allow both sequences to be iterated over seemlessly.
 * Thus, sending sequences will effectively merge them and the receiving system
 * will see one large sequence.
 * 
 * The sequences, data pointer and size must all be non-null or non-0.
 *
 * The merging sequence is NOT copied - it is the application responsibility to ensure the
 * integrity of data is maintained between this function being called and when other
 * functions use this sequence. I.E. The API's don't provide thread safety for the data
 *
 * This API is specifically designed to allow you to manage multiple sequences as one.
 *
 * \returns Whether the sequence reference was successfully added to the Sequence
 */
stk_ret stk_add_sequence_reference_in_sequence(stk_sequence_t *seq,stk_sequence_t *merge_seq, stk_uint64 user_type);

/**
 * stk_update_ref_data_in_sequence() updates the data generation of a sequence and
 * copies reference data if there are references to it for archival purposes. For
 * most efficiency, this API should be called when ready to modify data.
 * [Not implemented]
 *
 * \returns the generation ID of data archived in gen_id if not NULL
 */
stk_ret stk_update_ref_data_in_sequence(stk_sequence_t *seq, stk_generation_id *gen_id);

/**
 * Copy some data to the sequence.
 * The sequence, data pointer and size must all be non-null or non-0
 * \returns Whether the data was successfully copied to the Sequence
 */
stk_ret stk_copy_to_sequence(stk_sequence_t *seq,void *data_ptr,stk_uint64 sz, stk_uint64 user_type);

/**
 * Copy some data to the sequence meta data.
 * The sequence, data pointer and size must all be non-null or non-0
 *
 * Sequence meta data is considered local data and for example is not
 * transmitted by data flows. Meta data is managed independently
 * and uses separate APIs for adding/finding data in sequences.
 *
 * \returns Whether the data was successfully copied to the Sequence
 */
stk_ret stk_copy_to_sequence_meta_data(stk_sequence_t *seq,void *data_ptr,stk_uint64 sz, stk_uint64 user_type);

/**
 * Remove up to N instances of data of "user_type" from the sequence
 * \param seq The sequence to have items removed from
 * \param user_type The user type of the sequence element to be removed
 * \param max_instances The number of instances to be removed (or 0 for all [may be performance impacting])
 * \returns The number of instances removed
 */
stk_uint64 stk_remove_sequence_data_by_type(stk_sequence_t *seq, stk_uint64 user_type, stk_uint64 max_instances);

/**
 * API to return the ID of a sequence
 * \returns The ID of the Sequence
 * \see stk_create_sequnce()
 */
stk_sequence_id stk_get_sequence_id(stk_sequence_t *seq);

/**
 * API to set the ID of a sequence.
 * \returns Whether the ID was set
 */
stk_ret stk_set_sequence_id(stk_sequence_t *seq, stk_sequence_id id);

/**
 * API to return the Type of a sequence
 * \returns The Type of the Sequence
 * \see stk_create_sequence()
 */
stk_sequence_type stk_get_sequence_type(stk_sequence_t *seq);

/**
 * API to set the Type of a sequence.
 * \returns Whether the Type was set
 */
stk_ret stk_set_sequence_type(stk_sequence_t *seq,stk_sequence_type type);

/**
 * API to set the Name of a sequence.
 * This name should be dynamically allocated as stk_destroy_sequence() will free it.
 * \returns Whether the Name was set
 */
stk_ret stk_set_sequence_name(stk_sequence_t *seq,char *name);

/**
 * API to get the name of a sequence.
 * \returns The name of the sequence or NULL
 */
char *stk_get_sequence_name(stk_sequence_t *seq);

/**
 * Bump the generation ID of a sequence. This is used by data flow modules when sending sequences
 * \returns The old generation
 */
stk_generation_id stk_bump_sequence_generation(stk_sequence_t *seq);

/**
 * API to get a sequences generation
 */
stk_generation_id stk_get_sequence_generation(stk_sequence_t *seq);

/**
 * Get the STK Environment from a Sequence
 * \returns The environment which a sequence is associated with.
 */
stk_env_t *stk_env_from_sequence(stk_sequence_t *seq);

/**
 * API to determine the number of elements in a sequence
 *
 * Note, if a merged sequence exists, the total count will be returned.
 * \returns The total number of elements in the sequence
 */
int stk_number_of_sequence_elements(stk_sequence_t *seq);

/**
 * API to determine if a sequence has any elements
 *
 * \returns 0 if there are no elements, 1 if there are some elements
 */
int stk_has_any_sequence_elements(stk_sequence_t *seq);

/**
 * Allocate a sequence element at the end of the sequence
 * \returns Whether the element was allocated or not
 */
stk_ret stk_alloc_in_sequence(stk_sequence_t *seq,stk_uint64 sz, stk_uint64 user_type);

/**
 * API to get the last data element in the sequence
 * (Useful when appending data)
 * \returns A pointer to the last element data 
 */
void *stk_last_sequence_element(stk_sequence_t *seq);

/*
 * Following APIs are used to iterate over a sequence.
 * stk_iterate_sequence() is used when you want to apply a function as a callback to each element,
 * else a traditional set of iterator APIs allows app code to navigate a sequence.
 */

/**
 * API to execute a callback on each element in a sequence.
 *
 * The sequence (seq) may be a sequence or a sequence iterator (casted).
 *
 * Use of an iterator allows the callback use of other iterator APIs.
 *
 * Passing an iterator and using a merged sequence is not supported.
 *
 * \returns STK_SUCCESS if all the elements were iterated over (a callback returning failure halts iteration)
 */
stk_ret stk_iterate_sequence(stk_sequence_t *seq,stk_sequence_cb element_cb,void *clientd);

/**
 * API to execute a callback before iterating over elements, on each element in a sequence, and after.
 *
 * The sequence (seq) may be a sequence or a sequence iterator (casted).
 *
 * Use of an iterator allows the callback use of other iterator APIs.
 *
 * Passing an iterator and using a merged sequence is not supported.
 *
 * \returns STK_SUCCESS if all the elements were iterated over (a callback returning failure halts iteration, after_cb is still called)
 */
stk_ret stk_iterate_complete_sequence(stk_sequence_t *seq,
	stk_sequence_cb before_cb, stk_sequence_cb element_cb, stk_sequence_cb after_cb, void *clientd);

/**
 * Create an iterator for a sequence. Note a sequence can not be changed
 * while using an iterator on it.
 *
 * Note: this iterator does not support iterating over merged sequences.
 *       The merged sequences will be skipped.
 *       Use stk_iterate_sequence() instead.
 *
 * \returns a handle to an iterator for the given Sequence
 * \see stk_end_sequence_iterator()
 */
stk_sequence_iterator_t *stk_sequence_iterator(stk_sequence_t *seq);

/**
 * Frees the iterator
 * \returns Whether the iterator was successfully freed.
 */
stk_ret stk_end_sequence_iterator(stk_sequence_iterator_t *seqiter);

/**
 * API to realloc the iterators current data buffer 
 * \returns The newly allocated data pointer (may be the same)
 */
void *stk_sequence_iterator_realloc_segment(stk_sequence_iterator_t *seqiter,stk_uint64 sz);

/**
 * API to ensure a segment is a specific size, realloc'ing it if necessary.
 * \returns The data pointer sized at the requested size (may be the same or different)
 */
void *stk_sequence_iterator_ensure_segment_size(stk_sequence_iterator_t *seqiter,stk_uint64 sz);

/**
 * API to return the current data item
 * \returns the current data item pointed to by the iterator.
 */
void *stk_sequence_iterator_data(stk_sequence_iterator_t *seqiter);

/**
 * API to move the iterator to the next Sequence.
 * \returns the next data item pointed to by the iterator. Returns NULL at end, then wraps.
 */
void *stk_sequence_iterator_next(stk_sequence_iterator_t *seqiter);

/**
 * API to move the iterator to the previous Sequence.
 * \returns the previous data item pointed to by the iterator. Returns NULL at the start, then wraps.
 */
void *stk_sequence_iterator_prev(stk_sequence_iterator_t *seqiter);

/**
 * API to copy data in to an existing sequence element based on the current iterators position
 * \returns SUCCESS if data is copied, otherwise the data buffer is too small or there is no current object in the iterator
 */
stk_ret stk_sequence_iterator_copy_data(stk_sequence_iterator_t *seqiter,void *data_ptr,stk_uint64 sz);

/**
 * Get the size of the iterator's current sequence element
 * \returns The data size
 */
stk_uint64 stk_sequence_iterator_data_size(stk_sequence_iterator_t *seqiter);

/**
 * Get the allocated size of the iterator's current sequence element
 * \returns the allocated size (0 if not allocated)
 */
stk_uint64 stk_sequence_iterator_alloc_size(stk_sequence_iterator_t *seqiter);

/**
 * API to set the size of the data in the current sequence element.
 *
 * Can't be bigger than the allocated size of the buffer
 *
 * \returns STK_SUCCESS if the data size was set.
 */
stk_ret stk_sequence_iterator_set_size(stk_sequence_iterator_t *seqiter,stk_uint64 sz);

/**
 * API to set the current sequence elements user type.
 *
 * \returns STK_SUCCESS if the data size was set.
 */
stk_ret stk_sequence_iterator_set_user_type(stk_sequence_iterator_t *seqiter,stk_uint64 user_type);

/**
 * API to find an element by user type. Use of this API likely leads to slower applications
 * if used repeatedly. When searching for more than one item, use an iterator.
 *
 * \returns STK_SUCCESS if the user type was found or an error (E.G STK_NOT_FOUND if not)
 */
stk_ret stk_sequence_find_data_by_type(stk_sequence_t *seq,stk_uint64 user_type,void **data_ptr,stk_uint64 *sz);

/**
 * API to find an element by user type in the meta data.
 *
 * \returns STK_SUCCESS if the user type was found or an error (E.G STK_NOT_FOUND if not)
 */
stk_ret stk_sequence_find_meta_data_by_type(stk_sequence_t *seq,stk_uint64 user_type,void **data_ptr,stk_uint64 *sz);
#endif
